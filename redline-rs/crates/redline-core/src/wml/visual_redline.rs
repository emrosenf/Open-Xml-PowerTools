//! Visual Redline Transformation
//!
//! Transforms a DOCX with standard tracked changes (w:ins/w:del) into a visually-styled
//! document with:
//! - Insertions: Colored text (default blue) with double underline
//! - Deletions: Colored text (default red) with strikethrough
//! - Moves: Colored text (default green) - detected by matching text between ins/del
//! - Optional summary table at document end
//!
//! This is a post-processing step that can be applied to any document containing
//! OOXML tracked changes, whether generated by this library or by Microsoft Word.
//!
//! # Example
//!
//! ```ignore
//! use redline_core::wml::{render_visual_redline, VisualRedlineSettings};
//! use redline_core::WmlDocument;
//!
//! let doc = WmlDocument::from_bytes(&docx_bytes)?;
//! let settings = VisualRedlineSettings::default();
//! let result = render_visual_redline(&doc, &settings)?;
//! // result.document contains the transformed DOCX bytes
//! ```

use std::collections::{HashMap, HashSet};

use chrono::Local;
use serde::{Deserialize, Serialize};

use crate::xml::arena::XmlDocument;
use crate::xml::namespaces::W;
use crate::xml::node::XmlNodeData;
use crate::xml::xname::{XAttribute, XName};
use crate::wml::document::find_document_body;
use crate::wml::WmlDocument;
use crate::Result;
use crate::RedlineError;

use indextree::NodeId;

/// Settings for the visual redline transformation.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct VisualRedlineSettings {
    /// Color for insertions (hex RGB without #, e.g., "0000FF" for blue)
    pub insertion_color: String,

    /// Color for deletions (hex RGB without #, e.g., "FF0000" for red)
    pub deletion_color: String,

    /// Color for moved content (hex RGB without #, e.g., "008000" for green)
    pub move_color: String,

    /// Minimum word count for move detection (default: 5)
    pub move_detection_min_words: usize,

    /// Whether to add a summary table at the end of the document
    pub add_summary_table: bool,

    /// Original/older document filename (for summary table, optional)
    pub older_filename: Option<String>,

    /// Modified/newer document filename (for summary table, optional)
    pub newer_filename: Option<String>,
}

impl Default for VisualRedlineSettings {
    fn default() -> Self {
        Self {
            insertion_color: "0000FF".to_string(), // Blue
            deletion_color: "FF0000".to_string(),  // Red
            move_color: "008000".to_string(),      // Green
            move_detection_min_words: 5,
            add_summary_table: true,
            older_filename: None,
            newer_filename: None,
        }
    }
}

/// Result of the visual redline transformation.
#[derive(Debug, Clone)]
pub struct VisualRedlineResult {
    /// The transformed document as DOCX bytes
    pub document: Vec<u8>,

    /// Number of insertions processed
    pub insertions: usize,

    /// Number of deletions processed
    pub deletions: usize,

    /// Number of move pairs detected
    pub moves: usize,

    /// Number of format change elements removed
    pub format_changes_removed: usize,
}

/// Internal structure to track revision information during processing.
#[derive(Debug)]
struct RevisionInfo {
    /// The NodeId of the w:ins or w:del element
    node_id: NodeId,
    /// All w:r elements inside this revision
    runs: Vec<NodeId>,
    /// Extracted text content
    text: String,
    /// Normalized text for comparison (lowercase, collapsed whitespace)
    normalized_text: String,
    /// Word count of the text
    word_count: usize,
}

/// Statistics collected during transformation.
#[derive(Debug, Default)]
struct TransformStats {
    count: usize,
}

/// Renders a visual redline document from a document with tracked changes.
///
/// This function transforms tracked changes (w:ins/w:del) into visual formatting:
/// - Insertions become colored text with double underline
/// - Deletions become colored text with strikethrough
/// - Moved content (detected by matching text) uses a different color
///
/// # Arguments
///
/// * `doc` - The source document containing tracked changes
/// * `settings` - Configuration for colors, move detection, and summary table
///
/// # Returns
///
/// A `VisualRedlineResult` containing the transformed document and statistics.
pub fn render_visual_redline(
    doc: &WmlDocument,
    settings: &VisualRedlineSettings,
) -> Result<VisualRedlineResult> {
    // Clone the document to avoid modifying the original
    let bytes = doc.to_bytes()?;
    let mut result_doc = WmlDocument::from_bytes(&bytes)?;

    // Get the main document XML
    let mut main_doc = result_doc.main_document()?;
    let root = main_doc
        .root()
        .ok_or_else(|| RedlineError::XmlParse {
            message: "Document has no root".to_string(),
            location: "document.xml".to_string(),
        })?;

    // Collect all insertions and deletions
    let insertions = collect_insertions(&main_doc, root);
    let deletions = collect_deletions(&main_doc, root);

    // Detect moves by matching text
    let (move_insertion_indices, move_deletion_indices) =
        detect_moves(&insertions, &deletions, settings.move_detection_min_words);

    let moves_count = move_insertion_indices.len();

    // Transform insertions
    let insertion_stats =
        transform_insertions(&mut main_doc, &insertions, &move_insertion_indices, settings);

    // Transform deletions
    let deletion_stats =
        transform_deletions(&mut main_doc, &deletions, &move_deletion_indices, settings);

    // Remove rPrChange elements (keep current formatting)
    let format_changes_removed = remove_rpr_changes(&mut main_doc, root);

    // Add summary table if enabled
    if settings.add_summary_table {
        if let Some(body) = find_document_body(&main_doc) {
            add_summary_table(
                &mut main_doc,
                body,
                insertion_stats.count,
                deletion_stats.count,
                moves_count,
                format_changes_removed,
                settings,
            );
        }
    }

    // Save modified document back to package
    result_doc
        .package_mut()
        .put_xml_part("word/document.xml", &main_doc)?;

    Ok(VisualRedlineResult {
        document: result_doc.to_bytes()?,
        insertions: insertion_stats.count,
        deletions: deletion_stats.count,
        moves: moves_count,
        format_changes_removed,
    })
}

/// Collects all w:ins elements with their text content.
fn collect_insertions(doc: &XmlDocument, root: NodeId) -> Vec<RevisionInfo> {
    let ins_name = W::ins();
    let mut insertions = Vec::new();

    for node_id in doc.descendants(root) {
        if let Some(data) = doc.get(node_id) {
            if let Some(name) = data.name() {
                if name == &ins_name {
                    let runs = collect_runs_in_element(doc, node_id);
                    let text = extract_text_from_runs(doc, &runs, false);
                    let normalized = normalize_text(&text);
                    let word_count = normalized.split_whitespace().count();

                    insertions.push(RevisionInfo {
                        node_id,
                        runs,
                        text,
                        normalized_text: normalized,
                        word_count,
                    });
                }
            }
        }
    }

    insertions
}

/// Collects all w:del elements with their text content.
fn collect_deletions(doc: &XmlDocument, root: NodeId) -> Vec<RevisionInfo> {
    let del_name = W::del();
    let mut deletions = Vec::new();

    for node_id in doc.descendants(root) {
        if let Some(data) = doc.get(node_id) {
            if let Some(name) = data.name() {
                if name == &del_name {
                    let runs = collect_runs_in_element(doc, node_id);
                    let text = extract_text_from_runs(doc, &runs, true); // Use delText
                    let normalized = normalize_text(&text);
                    let word_count = normalized.split_whitespace().count();

                    deletions.push(RevisionInfo {
                        node_id,
                        runs,
                        text,
                        normalized_text: normalized,
                        word_count,
                    });
                }
            }
        }
    }

    deletions
}

/// Collects all w:r elements within a given element.
fn collect_runs_in_element(doc: &XmlDocument, element: NodeId) -> Vec<NodeId> {
    let r_name = W::r();
    let mut runs = Vec::new();

    for node_id in doc.descendants(element) {
        if let Some(data) = doc.get(node_id) {
            if let Some(name) = data.name() {
                if name == &r_name {
                    runs.push(node_id);
                }
            }
        }
    }

    runs
}

/// Extracts text content from runs.
fn extract_text_from_runs(doc: &XmlDocument, runs: &[NodeId], use_del_text: bool) -> String {
    let t_name = W::t();
    let del_text_name = W::delText();
    let mut text = String::new();

    for &run_id in runs {
        for node_id in doc.descendants(run_id) {
            if let Some(data) = doc.get(node_id) {
                if let Some(name) = data.name() {
                    let is_text = name == &t_name || (use_del_text && name == &del_text_name);
                    if is_text {
                        // Get text content from children
                        for child_id in doc.children(node_id) {
                            if let Some(child_data) = doc.get(child_id) {
                                if let Some(txt) = child_data.text_content() {
                                    text.push_str(txt);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    text
}

/// Normalizes text for comparison: lowercase and collapse whitespace.
fn normalize_text(text: &str) -> String {
    text.to_lowercase()
        .split_whitespace()
        .collect::<Vec<_>>()
        .join(" ")
}

/// Detects moved content by matching text between insertions and deletions.
///
/// Returns two sets: insertion indices and deletion indices that are detected as moves.
fn detect_moves(
    insertions: &[RevisionInfo],
    deletions: &[RevisionInfo],
    min_words: usize,
) -> (HashSet<usize>, HashSet<usize>) {
    let mut move_insertions = HashSet::new();
    let mut move_deletions = HashSet::new();

    // Build a map from normalized text to deletion indices for efficient lookup
    let mut deletion_map: HashMap<&str, Vec<usize>> = HashMap::new();
    for (idx, del) in deletions.iter().enumerate() {
        if del.word_count >= min_words {
            deletion_map
                .entry(&del.normalized_text)
                .or_default()
                .push(idx);
        }
    }

    // For each insertion, try to find a matching deletion
    for (ins_idx, insertion) in insertions.iter().enumerate() {
        if insertion.word_count < min_words {
            continue;
        }

        if let Some(del_indices) = deletion_map.get(insertion.normalized_text.as_str()) {
            // Find the first unused deletion
            for &del_idx in del_indices {
                if !move_deletions.contains(&del_idx) {
                    move_insertions.insert(ins_idx);
                    move_deletions.insert(del_idx);
                    break;
                }
            }
        }
    }

    (move_insertions, move_deletions)
}

/// Transforms insertion elements to visual formatting.
fn transform_insertions(
    doc: &mut XmlDocument,
    insertions: &[RevisionInfo],
    move_indices: &HashSet<usize>,
    settings: &VisualRedlineSettings,
) -> TransformStats {
    let mut stats = TransformStats::default();

    // Process in reverse order to avoid invalidating NodeIds
    for (idx, insertion) in insertions.iter().enumerate().rev() {
        let color = if move_indices.contains(&idx) {
            &settings.move_color
        } else {
            &settings.insertion_color
        };

        // Apply formatting to all runs
        for &run_id in &insertion.runs {
            apply_run_formatting(doc, run_id, color, Some("double"), false);
        }

        // Unwrap the w:ins element (keep children, remove wrapper)
        unwrap_element(doc, insertion.node_id);

        stats.count += 1;
    }

    stats
}

/// Transforms deletion elements to visual formatting.
fn transform_deletions(
    doc: &mut XmlDocument,
    deletions: &[RevisionInfo],
    move_indices: &HashSet<usize>,
    settings: &VisualRedlineSettings,
) -> TransformStats {
    let mut stats = TransformStats::default();

    // Process in reverse order to avoid invalidating NodeIds
    for (idx, deletion) in deletions.iter().enumerate().rev() {
        let color = if move_indices.contains(&idx) {
            &settings.move_color
        } else {
            &settings.deletion_color
        };

        // Apply formatting to all runs
        for &run_id in &deletion.runs {
            apply_run_formatting(doc, run_id, color, None, true);
            // Convert w:delText to w:t
            convert_del_text_to_text(doc, run_id);
        }

        // Unwrap the w:del element (keep children, remove wrapper)
        unwrap_element(doc, deletion.node_id);

        stats.count += 1;
    }

    stats
}

/// Applies visual formatting to a run element.
fn apply_run_formatting(
    doc: &mut XmlDocument,
    run_id: NodeId,
    color: &str,
    underline_type: Option<&str>,
    strikethrough: bool,
) {
    let rpr_name = W::rPr();

    // Find or create w:rPr child
    let rpr_id = match find_child_by_name(doc, run_id, &rpr_name) {
        Some(id) => id,
        None => {
            // Create rPr and insert at beginning of run
            let new_rpr = doc.new_node(XmlNodeData::element(rpr_name.clone()));

            // Get first child before mutating
            let first_child = doc.children(run_id).next();

            // Insert before first child or append to run
            if let Some(first) = first_child {
                doc.insert_before(first, new_rpr);
            } else {
                doc.reparent(run_id, new_rpr);
            }
            new_rpr
        }
    };

    // Add/update w:color element
    let color_name = W::color();
    let val_name = W::val();

    if let Some(color_id) = find_child_by_name(doc, rpr_id, &color_name) {
        doc.set_attribute(color_id, &val_name, color);
    } else {
        let color_elem = doc.add_child(
            rpr_id,
            XmlNodeData::element_with_attrs(color_name, vec![XAttribute::new(val_name.clone(), color)]),
        );
        // Move color element to appropriate position in rPr
        // For simplicity, we just append; Word will normalize order
        let _ = color_elem;
    }

    // Add w:u (underline) for insertions
    if let Some(underline_val) = underline_type {
        let u_name = W::u();
        if let Some(u_id) = find_child_by_name(doc, rpr_id, &u_name) {
            doc.set_attribute(u_id, &val_name, underline_val);
        } else {
            doc.add_child(
                rpr_id,
                XmlNodeData::element_with_attrs(u_name, vec![XAttribute::new(val_name.clone(), underline_val)]),
            );
        }
    }

    // Add w:strike for deletions
    if strikethrough {
        let strike_name = W::strike();
        if find_child_by_name(doc, rpr_id, &strike_name).is_none() {
            doc.add_child(rpr_id, XmlNodeData::element(strike_name));
        }
    }
}

/// Converts w:delText elements to w:t elements within a run.
fn convert_del_text_to_text(doc: &mut XmlDocument, run_id: NodeId) {
    let del_text_name = W::delText();
    let t_name = W::t();

    // Collect nodes to modify first to avoid borrow issues
    let nodes_to_convert: Vec<NodeId> = doc
        .descendants(run_id)
        .filter(|&node_id| {
            doc.get(node_id)
                .and_then(|data| data.name())
                .map(|n| n == &del_text_name)
                .unwrap_or(false)
        })
        .collect();

    // Rename elements from w:delText to w:t
    for node_id in nodes_to_convert {
        if let Some(data) = doc.get_mut(node_id) {
            if let XmlNodeData::Element { name, .. } = data {
                *name = t_name.clone();
            }
        }
    }
}

/// Removes all w:rPrChange elements from the document.
fn remove_rpr_changes(doc: &mut XmlDocument, root: NodeId) -> usize {
    let rpr_change_name = W::rPrChange();

    // Collect all rPrChange elements
    let nodes_to_remove: Vec<NodeId> = doc
        .descendants(root)
        .filter(|&node_id| {
            doc.get(node_id)
                .and_then(|data| data.name())
                .map(|n| n == &rpr_change_name)
                .unwrap_or(false)
        })
        .collect();

    let count = nodes_to_remove.len();

    // Remove them
    for node_id in nodes_to_remove {
        doc.remove(node_id);
    }

    count
}

/// Unwraps an element, moving its children to its parent.
fn unwrap_element(doc: &mut XmlDocument, element: NodeId) {
    // Get parent
    let parent = match doc.parent(element) {
        Some(p) => p,
        None => return, // Root element, can't unwrap
    };

    // Collect children
    let children: Vec<NodeId> = doc.children(element).collect();

    // Insert each child before the element we're unwrapping
    for child in children {
        doc.insert_before(element, child);
    }

    // Remove the now-empty wrapper element
    doc.remove(element);

    // Suppress warning about unused parent
    let _ = parent;
}

/// Finds a child element by name.
fn find_child_by_name(doc: &XmlDocument, parent: NodeId, name: &XName) -> Option<NodeId> {
    doc.children(parent).find(|&child_id| {
        doc.get(child_id)
            .and_then(|data| data.name())
            .map(|n| n == name)
            .unwrap_or(false)
    })
}

/// Adds a summary table to the document.
fn add_summary_table(
    doc: &mut XmlDocument,
    body: NodeId,
    insertions: usize,
    deletions: usize,
    moves: usize,
    format_changes: usize,
    settings: &VisualRedlineSettings,
) {
    let now = Local::now().format("%m/%d/%Y %I:%M:%S %p").to_string();

    // Add page break before summary
    let page_break_p = create_page_break(doc);
    doc.reparent(body, page_break_p);

    // Create table
    let tbl = doc.add_child(body, XmlNodeData::element(W::tbl()));

    // Add table properties
    add_table_properties(doc, tbl);

    // Add table grid (2 columns)
    add_table_grid(doc, tbl);

    // Title row: "Summary Report"
    add_header_row(doc, tbl, "Summary Report", true, Some("E8E8E8"));

    // Subtitle row: comparison date
    add_header_row(
        doc,
        tbl,
        &format!("Document comparison performed on {}", now),
        false,
        None,
    );

    // Filename rows (only if provided)
    if let Some(ref older) = settings.older_filename {
        add_info_row(doc, tbl, "Original filename:", older);
    }
    if let Some(ref newer) = settings.newer_filename {
        add_info_row(doc, tbl, "Modified filename:", newer);
    }

    // Changes header
    add_header_row(doc, tbl, "Changes:", false, Some("F5F5F5"));

    // Change type rows with visual styling
    add_data_row(
        doc,
        tbl,
        "Insertions",
        &insertions.to_string(),
        Some(&settings.insertion_color),
        Some("single"),
        false,
    );

    add_data_row(
        doc,
        tbl,
        "Deletions",
        &deletions.to_string(),
        Some(&settings.deletion_color),
        None,
        true,
    );

    add_data_row(
        doc,
        tbl,
        "Moves",
        &moves.to_string(),
        Some(&settings.move_color),
        None,
        false,
    );

    add_data_row(
        doc,
        tbl,
        "Format changes",
        &format_changes.to_string(),
        None,
        None,
        false,
    );

    // Total row
    let total = insertions + deletions + moves + format_changes;
    add_total_row(doc, tbl, "Total Changes:", &total.to_string());
}

/// Creates a paragraph with a page break.
fn create_page_break(doc: &mut XmlDocument) -> NodeId {
    let p = doc.new_node(XmlNodeData::element(W::p()));
    let r = doc.add_child(p, XmlNodeData::element(W::r()));
    let br = doc.add_child(
        r,
        XmlNodeData::element_with_attrs(W::br(), vec![XAttribute::new(W::type_(), "page")]),
    );
    let _ = br;
    p
}

/// Adds table properties for the summary table.
fn add_table_properties(doc: &mut XmlDocument, tbl: NodeId) {
    let tbl_pr = doc.add_child(tbl, XmlNodeData::element(W::tblPr()));

    // Center the table
    doc.add_child(
        tbl_pr,
        XmlNodeData::element_with_attrs(W::jc(), vec![XAttribute::new(W::val(), "center")]),
    );

    // Table width (60% of page)
    doc.add_child(
        tbl_pr,
        XmlNodeData::element_with_attrs(
            W::tblW(),
            vec![
                XAttribute::new(W::w_val(), "6000"),
                XAttribute::new(W::type_(), "pct"),
            ],
        ),
    );

    // Table borders
    let tbl_borders = doc.add_child(tbl_pr, XmlNodeData::element(W::tblBorders()));
    for border_name_fn in [W::top, W::left, W::bottom, W::right, W::insideH, W::insideV] {
        doc.add_child(
            tbl_borders,
            XmlNodeData::element_with_attrs(
                border_name_fn(),
                vec![
                    XAttribute::new(W::val(), "single"),
                    XAttribute::new(XName::new(W::NS, "sz"), "4"),
                    XAttribute::new(W::space(), "0"),
                    XAttribute::new(W::color(), "000000"),
                ],
            ),
        );
    }
}

/// Adds the table grid definition.
fn add_table_grid(doc: &mut XmlDocument, tbl: NodeId) {
    let tbl_grid = doc.add_child(tbl, XmlNodeData::element(W::tblGrid()));
    doc.add_child(
        tbl_grid,
        XmlNodeData::element_with_attrs(W::gridCol(), vec![XAttribute::new(W::w_val(), "5000")]),
    );
    doc.add_child(
        tbl_grid,
        XmlNodeData::element_with_attrs(W::gridCol(), vec![XAttribute::new(W::w_val(), "1500")]),
    );
}

/// Adds a header row spanning both columns.
fn add_header_row(
    doc: &mut XmlDocument,
    tbl: NodeId,
    text: &str,
    bold: bool,
    shading: Option<&str>,
) {
    let tr = doc.add_child(tbl, XmlNodeData::element(W::tr()));
    let tc = doc.add_child(tr, XmlNodeData::element(W::tc()));

    // Cell properties
    let tc_pr = doc.add_child(tc, XmlNodeData::element(W::tcPr()));
    doc.add_child(
        tc_pr,
        XmlNodeData::element_with_attrs(W::gridSpan(), vec![XAttribute::new(W::val(), "2")]),
    );

    if let Some(shade_color) = shading {
        doc.add_child(
            tc_pr,
            XmlNodeData::element_with_attrs(
                W::shd(),
                vec![
                    XAttribute::new(W::val(), "clear"),
                    XAttribute::new(W::color(), "auto"),
                    XAttribute::new(W::fill(), shade_color),
                ],
            ),
        );
    }

    // Paragraph
    let p = doc.add_child(tc, XmlNodeData::element(W::p()));
    let p_pr = doc.add_child(p, XmlNodeData::element(W::pPr()));
    doc.add_child(
        p_pr,
        XmlNodeData::element_with_attrs(W::jc(), vec![XAttribute::new(W::val(), "center")]),
    );

    // Run with text
    let r = doc.add_child(p, XmlNodeData::element(W::r()));
    if bold {
        let r_pr = doc.add_child(r, XmlNodeData::element(W::rPr()));
        doc.add_child(r_pr, XmlNodeData::element(W::b()));
    }

    let t = doc.add_child(r, XmlNodeData::element(W::t()));
    doc.add_child(t, XmlNodeData::text(text));
}

/// Adds an info row with label and value merged.
fn add_info_row(doc: &mut XmlDocument, tbl: NodeId, label: &str, value: &str) {
    let tr = doc.add_child(tbl, XmlNodeData::element(W::tr()));
    let tc = doc.add_child(tr, XmlNodeData::element(W::tc()));

    // Cell properties - merge both columns
    let tc_pr = doc.add_child(tc, XmlNodeData::element(W::tcPr()));
    doc.add_child(
        tc_pr,
        XmlNodeData::element_with_attrs(W::gridSpan(), vec![XAttribute::new(W::val(), "2")]),
    );

    // Paragraph with label (bold) and value
    let p = doc.add_child(tc, XmlNodeData::element(W::p()));

    // Bold label run
    let r1 = doc.add_child(p, XmlNodeData::element(W::r()));
    let r_pr1 = doc.add_child(r1, XmlNodeData::element(W::rPr()));
    doc.add_child(r_pr1, XmlNodeData::element(W::b()));
    let t1 = doc.add_child(r1, XmlNodeData::element(W::t()));
    doc.add_child(t1, XmlNodeData::text(label));

    // Value run
    let r2 = doc.add_child(p, XmlNodeData::element(W::r()));
    let t2 = doc.add_child(
        r2,
        XmlNodeData::element_with_attrs(
            W::t(),
            vec![XAttribute::new(
                XName::new("http://www.w3.org/XML/1998/namespace", "space"),
                "preserve",
            )],
        ),
    );
    doc.add_child(t2, XmlNodeData::text(&format!(" {}", value)));
}

/// Adds a data row with label (styled) and value.
fn add_data_row(
    doc: &mut XmlDocument,
    tbl: NodeId,
    label: &str,
    value: &str,
    color: Option<&str>,
    underline: Option<&str>,
    strikethrough: bool,
) {
    let tr = doc.add_child(tbl, XmlNodeData::element(W::tr()));

    // Label cell
    let tc1 = doc.add_child(tr, XmlNodeData::element(W::tc()));
    doc.add_child(tc1, XmlNodeData::element(W::tcPr()));
    let p1 = doc.add_child(tc1, XmlNodeData::element(W::p()));
    let r1 = doc.add_child(p1, XmlNodeData::element(W::r()));

    // Apply styling if provided
    if color.is_some() || underline.is_some() || strikethrough {
        let r_pr = doc.add_child(r1, XmlNodeData::element(W::rPr()));
        if let Some(c) = color {
            doc.add_child(
                r_pr,
                XmlNodeData::element_with_attrs(W::color(), vec![XAttribute::new(W::val(), c)]),
            );
        }
        if let Some(u) = underline {
            doc.add_child(
                r_pr,
                XmlNodeData::element_with_attrs(W::u(), vec![XAttribute::new(W::val(), u)]),
            );
        }
        if strikethrough {
            doc.add_child(r_pr, XmlNodeData::element(W::strike()));
        }
    }

    let t1 = doc.add_child(r1, XmlNodeData::element(W::t()));
    doc.add_child(t1, XmlNodeData::text(label));

    // Value cell (right-aligned)
    let tc2 = doc.add_child(tr, XmlNodeData::element(W::tc()));
    doc.add_child(tc2, XmlNodeData::element(W::tcPr()));
    let p2 = doc.add_child(tc2, XmlNodeData::element(W::p()));
    let p_pr2 = doc.add_child(p2, XmlNodeData::element(W::pPr()));
    doc.add_child(
        p_pr2,
        XmlNodeData::element_with_attrs(W::jc(), vec![XAttribute::new(W::val(), "right")]),
    );

    let r2 = doc.add_child(p2, XmlNodeData::element(W::r()));
    let t2 = doc.add_child(r2, XmlNodeData::element(W::t()));
    doc.add_child(t2, XmlNodeData::text(value));
}

/// Adds a total row with bold styling and shading.
fn add_total_row(doc: &mut XmlDocument, tbl: NodeId, label: &str, value: &str) {
    let tr = doc.add_child(tbl, XmlNodeData::element(W::tr()));

    // Label cell with shading
    let tc1 = doc.add_child(tr, XmlNodeData::element(W::tc()));
    let tc_pr1 = doc.add_child(tc1, XmlNodeData::element(W::tcPr()));
    doc.add_child(
        tc_pr1,
        XmlNodeData::element_with_attrs(
            W::shd(),
            vec![
                XAttribute::new(W::val(), "clear"),
                XAttribute::new(W::color(), "auto"),
                XAttribute::new(W::fill(), "F0F0F0"),
            ],
        ),
    );

    let p1 = doc.add_child(tc1, XmlNodeData::element(W::p()));
    let r1 = doc.add_child(p1, XmlNodeData::element(W::r()));
    let r_pr1 = doc.add_child(r1, XmlNodeData::element(W::rPr()));
    doc.add_child(r_pr1, XmlNodeData::element(W::b()));
    let t1 = doc.add_child(r1, XmlNodeData::element(W::t()));
    doc.add_child(t1, XmlNodeData::text(label));

    // Value cell with shading
    let tc2 = doc.add_child(tr, XmlNodeData::element(W::tc()));
    let tc_pr2 = doc.add_child(tc2, XmlNodeData::element(W::tcPr()));
    doc.add_child(
        tc_pr2,
        XmlNodeData::element_with_attrs(
            W::shd(),
            vec![
                XAttribute::new(W::val(), "clear"),
                XAttribute::new(W::color(), "auto"),
                XAttribute::new(W::fill(), "F0F0F0"),
            ],
        ),
    );

    let p2 = doc.add_child(tc2, XmlNodeData::element(W::p()));
    let p_pr2 = doc.add_child(p2, XmlNodeData::element(W::pPr()));
    doc.add_child(
        p_pr2,
        XmlNodeData::element_with_attrs(W::jc(), vec![XAttribute::new(W::val(), "right")]),
    );

    let r2 = doc.add_child(p2, XmlNodeData::element(W::r()));
    let r_pr2 = doc.add_child(r2, XmlNodeData::element(W::rPr()));
    doc.add_child(r_pr2, XmlNodeData::element(W::b()));
    let t2 = doc.add_child(r2, XmlNodeData::element(W::t()));
    doc.add_child(t2, XmlNodeData::text(value));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_normalize_text() {
        assert_eq!(normalize_text("  Hello   World  "), "hello world");
        assert_eq!(normalize_text("The Quick Brown Fox"), "the quick brown fox");
        assert_eq!(normalize_text(""), "");
        assert_eq!(normalize_text("   "), "");
    }

    #[test]
    fn test_default_settings() {
        let settings = VisualRedlineSettings::default();
        assert_eq!(settings.insertion_color, "0000FF");
        assert_eq!(settings.deletion_color, "FF0000");
        assert_eq!(settings.move_color, "008000");
        assert_eq!(settings.move_detection_min_words, 5);
        assert!(settings.add_summary_table);
        assert!(settings.older_filename.is_none());
        assert!(settings.newer_filename.is_none());
    }

    #[test]
    fn test_detect_moves_empty() {
        let insertions: Vec<RevisionInfo> = vec![];
        let deletions: Vec<RevisionInfo> = vec![];

        let (move_ins, move_del) = detect_moves(&insertions, &deletions, 5);
        assert!(move_ins.is_empty());
        assert!(move_del.is_empty());
    }
}
