/**
 * Test setup and helper utilities for document comparison tests.
 *
 * This file provides:
 * - Fixture loading helpers
 * - Document extraction utilities
 * - Golden file comparison helpers
 * - Common test utilities
 */

import { readFile, access } from 'fs/promises';
import { constants } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import JSZip from 'jszip';

// Get the directory of this file
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Path to test files (relative to redline-js/tests)
export const TEST_FILES_DIR = join(__dirname, '../../TestFiles');
export const GOLDEN_FILES_DIR = join(__dirname, 'golden');

/**
 * Load a docx/xlsx/pptx file as a Buffer
 */
export async function loadDocument(relativePath: string): Promise<Buffer> {
  const fullPath = join(TEST_FILES_DIR, relativePath);
  return readFile(fullPath);
}

/**
 * Check if a test fixture file exists
 */
export async function fixtureExists(relativePath: string): Promise<boolean> {
  const fullPath = join(TEST_FILES_DIR, relativePath);
  try {
    await access(fullPath, constants.R_OK);
    return true;
  } catch {
    return false;
  }
}

/**
 * Load a golden file (expected output)
 */
export async function loadGoldenFile(relativePath: string): Promise<Buffer> {
  const fullPath = join(GOLDEN_FILES_DIR, relativePath);
  return readFile(fullPath);
}

/**
 * Load the test manifest (generated by GoldenFileGenerator)
 */
export async function loadManifest(): Promise<TestManifest> {
  const manifestPath = join(GOLDEN_FILES_DIR, 'manifest.json');
  const content = await readFile(manifestPath, 'utf-8');
  return JSON.parse(content);
}

/**
 * Extract a specific file from a ZIP-based document (docx, xlsx, pptx)
 */
export async function extractFromZip(
  documentBuffer: Buffer,
  innerPath: string
): Promise<string> {
  const zip = await JSZip.loadAsync(documentBuffer);
  const file = zip.file(innerPath);
  if (!file) {
    throw new Error(`File not found in ZIP: ${innerPath}`);
  }
  return file.async('string');
}

/**
 * Extract document.xml from a Word document
 */
export async function extractDocumentXml(docxBuffer: Buffer): Promise<string> {
  return extractFromZip(docxBuffer, 'word/document.xml');
}

/**
 * Extract all XML parts from a Word document
 */
export async function extractAllWordParts(
  docxBuffer: Buffer
): Promise<Map<string, string>> {
  const zip = await JSZip.loadAsync(docxBuffer);
  const parts = new Map<string, string>();

  const xmlPaths = [
    'word/document.xml',
    'word/styles.xml',
    'word/numbering.xml',
    'word/footnotes.xml',
    'word/endnotes.xml',
    'word/comments.xml',
    'word/settings.xml',
    '[Content_Types].xml',
    'word/_rels/document.xml.rels',
  ];

  for (const path of xmlPaths) {
    const file = zip.file(path);
    if (file) {
      parts.set(path, await file.async('string'));
    }
  }

  return parts;
}

/**
 * Count revision elements (w:ins, w:del) in XML content
 */
export function countRevisions(xml: string): RevisionCounts {
  const W_NS = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main';

  // Simple regex-based counting (faster than parsing for large documents)
  const insCount = (xml.match(/<w:ins\b/g) || []).length;
  const delCount = (xml.match(/<w:del\b/g) || []).length;
  const rPrChangeCount = (xml.match(/<w:rPrChange\b/g) || []).length;

  return {
    insertions: insCount,
    deletions: delCount,
    formattingChanges: rPrChangeCount,
    total: insCount + delCount,
  };
}

/**
 * Normalize XML for comparison by removing insignificant whitespace and sorting attributes
 */
export function normalizeXml(xml: string): string {
  return xml
    // Remove XML declaration
    .replace(/<\?xml[^?]*\?>/g, '')
    // Normalize whitespace between elements
    .replace(/>\s+</g, '><')
    // Normalize attribute whitespace
    .replace(/\s+/g, ' ')
    // Remove leading/trailing whitespace
    .trim();
}

/**
 * Compare two XML strings for semantic equality
 */
export function xmlEquals(xml1: string, xml2: string): boolean {
  return normalizeXml(xml1) === normalizeXml(xml2);
}

// Type definitions

export interface TestManifest {
  generatedAt: string;
  wmlTests: WmlTestCase[];
  smlTests: SmlTestCase[];
  pmlTests: PmlTestCase[];
}

export interface WmlTestCase {
  testId: string;
  source1: string;
  source2: string;
  expectedRevisions: number;
  actualRevisions: number;
  revisions: RevisionDetail[];
  sanityCheck1Pass: boolean;
  sanityCheck1Error?: string;
  sanityCheck2Pass: boolean;
  sanityCheck2Error?: string;
  outputFile?: string;
  documentXmlFile?: string;
  error?: string;
}

export interface RevisionDetail {
  type: string;
  text?: string;
  author?: string;
}

export interface SmlTestCase {
  testId: string;
  description?: string;
  source1?: string;
  source2?: string;
  totalChanges: number;
  outputFile?: string;
  error?: string;
}

export interface PmlTestCase {
  testId: string;
  source1: string;
  source2: string;
  description?: string;
  totalChanges: number;
  slidesInserted: number;
  slidesDeleted: number;
  shapesInserted: number;
  shapesDeleted: number;
  shapesMoved: number;
  shapesResized: number;
  textChanges: number;
  outputFile?: string;
  error?: string;
}

export interface RevisionCounts {
  insertions: number;
  deletions: number;
  formattingChanges: number;
  total: number;
}

/**
 * Skip test if fixture files are missing
 */
export async function skipIfMissingFixtures(
  ...relativePaths: string[]
): Promise<boolean> {
  for (const path of relativePaths) {
    if (!(await fixtureExists(path))) {
      console.log(`Skipping test: missing fixture ${path}`);
      return true;
    }
  }
  return false;
}
